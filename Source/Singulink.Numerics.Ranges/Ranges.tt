<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// <auto-generated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

#nullable enable

namespace Singulink.Numerics;

<#
    (string name, string type, string countType)[] ranges = new[]
    {
        ("Range8", "byte", "int"),
        ("Range16", "short", "int"),
        ("Range32", "int", "long"),
        ("Range64", "long", "ulong"),
        ("SRange8", "sbyte", "int"),
        ("URange16", "ushort", "int"),
        ("URange32", "uint", "long"),
        ("URange64", "ulong", "ulong"),
    };

    foreach ((string name, string type, string countType) in ranges) {
#>
/// <summary>
/// Represents a range of <see cref="<#= type #>"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct <#= name #> : IRange<<#= type #>>, IEquatable<<#= name #>>, IAnyRange
{
    private static EmptyRangeEqualityComparer<<#= name #>>? _emptyEqualityComparer;

    private readonly <#= type #> _start;
    private readonly <#= type #> _end;

    /// <summary>
    /// Creates a new instance of the <#= name #> structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public <#= name #>(<#= type #> start, <#= type #> end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the <#= name #> structure with a single value in the range. The value must be less than <see cref="<#= type #>.MaxValue"/>.
    /// </summary>
    public static <#= name #> SingleValue(<#= type #> value)
    {
        if (value == <#= type #>.MaxValue)
            Throw.Value_OutOfRange();

        return new <#= name #>(value, (<#= type #>)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the <#= name #> structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="<#= type #>.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static <#= name #> Inclusive(<#= type #> start, <#= type #> end)
    {
        if (end == <#= type #>.MaxValue)
            Throw.End_OutOfRange();

        return new <#= name #>(start, (<#= type #>)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(<#= name #> x, <#= name #> y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(<#= name #> x, <#= name #> y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static <#= name #> Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<<#= name #>> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public <#= type #> Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public <#= type #> End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public <#= countType #> Count => IsEmpty ? 0 : (<#= countType #>)_end - (<#= countType #>)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public <#= name #> StartAt(<#= type #> start) => new <#= name #>(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public <#= name #> EndAt(<#= type #> end) => new <#= name #>(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="<#= type #>.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public <#= name #> EndAtInclusive(<#= type #> end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public <#= name #> ExpandToInclude(<#= type #> value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new <#= name #>(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public <#= name #> IntersectWith(<#= name #> range) => new <#= name #>(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public <#= name #> UnionWith(<#= name #> range)
    {
        <#= name #> result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(<#= name #> range, out <#= name #> result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<<#= name #>> Coalesce(IEnumerable<<#= name #>> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<<#= name #>> CoalesceOrdered(IEnumerable<<#= name #>> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        <#= name #> previous;
        <#= name #> next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(<#= name #> previous, <#= name #> next, ref <#= name #> result)
    {
        if (next._start <= previous._end)
        {
            result = new <#= name #>(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<<#= name #>> enumerator, out <#= name #> result)
    {
        <#= name #> current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(<#= name #> other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is <#= name #> range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<<#= type #>> IEnumerable<<#= type #>>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<<#= type #>>
    {
        private readonly <#= type #> _end;
        private <#= type #> _current;
        private <#= type #> _next;

        internal Enumerator(<#= type #> start, <#= type #> end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public <#= type #> Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

<# } #>