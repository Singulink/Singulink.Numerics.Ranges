<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    (string name, string type, string countType)[] ranges = new []
    {
	    ("Range8", "byte", "int"),
	    ("Range16", "short", "int"),
	    ("Range32", "int", "long"),
	    ("Range64", "long", "ulong"),
	    ("SRange8", "sbyte", "int"),
	    ("URange16", "ushort", "int"),
	    ("URange32", "uint", "long"),
	    ("URange64", "ulong", "ulong"),
    };
#>
// <auto-generated/>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

#nullable enable

namespace Singulink
{
<# foreach ((string name, string type, string countType) in ranges) { #>
    /// <summary>
    /// Represents a range of <see cref="<#= type #>"/> values.
    /// </summary>
    public readonly struct <#= name #> : IEquatable<<#= name #>>, IEnumerable<<#= type #>>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static <#= name #> Empty => default;

        private readonly <#= type #> _start;
        private readonly <#= type #> _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the <#= name #> structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public <#= name #>(<#= type #> start, <#= type #> end)
        {
<# if (type.Contains("64")) { #>
            if (end == <#= type #>.MaxValue && start == <#= type #>.MinValue) {
                throw new ArgumentException("The specified range has too many elements to count - 64 bit ranges have a max size of 1 less than the full available range.");
            }
<# } #>
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the <#= type #> structure with the specified start and end value.
        /// </summary>
        public <#= name #>(<#= type #> startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(<#= name #> x, <#= name #> y) => x.Equals(y);

        public static bool operator !=(<#= name #> x, <#= name #> y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public <#= type #> Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public <#= type #> End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public <#= countType #> Count => _isNotEmpty ? (<#= countType #>)_end - (<#= countType #>)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public <#= name #> StartAt(<#= type #> start) => new <#= name #>(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public <#= name #> EndAt(<#= type #> end) => new <#= name #>(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public <#= name #> IntersectWith(<#= name #> range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new <#= name #>(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public <#= name #> UnionWith(<#= name #> range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(<#= name #> range, out <#= name #> result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<<#= name #>> Coalesce(IEnumerable<<#= name #>> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref <#= name #> range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            <#= name #> first;
            <#= name #> second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new <#= name #>(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(<#= name #> other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is <#= name #> range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<<#= type #>> IEnumerable<<#= type #>>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<<#= type #>>
        {
            private readonly <#= type #> _end;
            private <#= type #> _current;
            private <#= type #> _next;

            internal Enumerator(<#= type #> start, <#= type #> end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != <#= type #>.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public <#= type #> Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

<# } #>
}