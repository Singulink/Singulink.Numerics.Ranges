// <auto-generated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

#nullable enable

namespace Singulink.Numerics;

/// <summary>
/// Represents a range of <see cref="byte"/> values with an inclusive start and end.
/// </summary>
[DebuggerDisplay("[{Start}..{End}], Count: {Count}")]
public readonly struct InclusiveRange8 : IInclusiveRange<byte>, IEquatable<InclusiveRange8>, IAnyRange
{
    private static EmptyRangeEqualityComparer<InclusiveRange8>? _emptyEqualityComparer;

    private readonly byte _start;
    private readonly byte _end;

    /// <summary>
    /// Creates a new instance of the InclusiveRange8 structure with the specified start and inclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then an empty range is created.
    /// </remarks>
    public InclusiveRange8(byte start, byte end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the InclusiveRange8 structure with a single value in the range.
    /// </summary>
    public static InclusiveRange8 SingleValue(byte value)
    {
        return new InclusiveRange8(value, value);
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator ==(InclusiveRange8 x, InclusiveRange8 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator !=(InclusiveRange8 x, InclusiveRange8 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <see cref="byte.MaxValue"/> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static InclusiveRange8 Empty => new InclusiveRange8(byte.MaxValue, 0);

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<InclusiveRange8> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the start of the range.
    /// </summary>
    public byte Start => _start;

    /// <summary>
    /// Gets the end of the range.
    /// </summary>
    public byte End => _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public int Count => IsEmpty ? 0 : (int)_end - (int)_start + 1;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start > _end;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range.
    /// </summary>
    public InclusiveRange8 StartAt(byte start) => new(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value.
    /// </summary>
    public InclusiveRange8 EndAt(byte end) => new(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public InclusiveRange8 ExpandToInclude(byte value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value > _end)
            return EndAt(value);

        if (value < _start)
            return StartAt(value);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range and returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public InclusiveRange8 IntersectWith(InclusiveRange8 range) => new InclusiveRange8(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. Throws
    /// <see cref="ArgumentException"/> if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public InclusiveRange8 UnionWith(InclusiveRange8 range)
    {
        InclusiveRange8 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. Returns false if there
    /// is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(InclusiveRange8 range, out InclusiveRange8 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<InclusiveRange8> Coalesce(IEnumerable<InclusiveRange8> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<InclusiveRange8> CoalesceOrdered(IEnumerable<InclusiveRange8> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        InclusiveRange8 previous;
        InclusiveRange8 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(InclusiveRange8 previous, InclusiveRange8 next, ref InclusiveRange8 result)
    {
        if (next._start == byte.MinValue || next._start - 1 <= previous._end)
        {
            result = new InclusiveRange8(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<InclusiveRange8> enumerator, out InclusiveRange8 result)
    {
        InclusiveRange8 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Object Method Implementations

    /// <summary>
    /// Determines if this range is equal to the specified range. Empty ranges are only considered equal if their start and end values match.
    /// </summary>
    /// <remarks>
    ///
    /// </remarks>
    public bool Equals(InclusiveRange8 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the given object.
    /// </summary>
    public override bool Equals(object? obj) => obj is InclusiveRange8 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region IEnumerable

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<byte> IEnumerable<byte>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<byte>
    {
        private readonly byte _end;
        private byte _current;
        private byte _next;

        internal Enumerator(byte start, byte end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next <= _end && _current != byte.MaxValue)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public byte Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="short"/> values with an inclusive start and end.
/// </summary>
[DebuggerDisplay("[{Start}..{End}], Count: {Count}")]
public readonly struct InclusiveRange16 : IInclusiveRange<short>, IEquatable<InclusiveRange16>, IAnyRange
{
    private static EmptyRangeEqualityComparer<InclusiveRange16>? _emptyEqualityComparer;

    private readonly short _start;
    private readonly short _end;

    /// <summary>
    /// Creates a new instance of the InclusiveRange16 structure with the specified start and inclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then an empty range is created.
    /// </remarks>
    public InclusiveRange16(short start, short end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the InclusiveRange16 structure with a single value in the range.
    /// </summary>
    public static InclusiveRange16 SingleValue(short value)
    {
        return new InclusiveRange16(value, value);
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator ==(InclusiveRange16 x, InclusiveRange16 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator !=(InclusiveRange16 x, InclusiveRange16 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <see cref="short.MaxValue"/> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static InclusiveRange16 Empty => new InclusiveRange16(short.MaxValue, 0);

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<InclusiveRange16> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the start of the range.
    /// </summary>
    public short Start => _start;

    /// <summary>
    /// Gets the end of the range.
    /// </summary>
    public short End => _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public int Count => IsEmpty ? 0 : (int)_end - (int)_start + 1;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start > _end;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range.
    /// </summary>
    public InclusiveRange16 StartAt(short start) => new(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value.
    /// </summary>
    public InclusiveRange16 EndAt(short end) => new(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public InclusiveRange16 ExpandToInclude(short value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value > _end)
            return EndAt(value);

        if (value < _start)
            return StartAt(value);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range and returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public InclusiveRange16 IntersectWith(InclusiveRange16 range) => new InclusiveRange16(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. Throws
    /// <see cref="ArgumentException"/> if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public InclusiveRange16 UnionWith(InclusiveRange16 range)
    {
        InclusiveRange16 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. Returns false if there
    /// is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(InclusiveRange16 range, out InclusiveRange16 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<InclusiveRange16> Coalesce(IEnumerable<InclusiveRange16> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<InclusiveRange16> CoalesceOrdered(IEnumerable<InclusiveRange16> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        InclusiveRange16 previous;
        InclusiveRange16 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(InclusiveRange16 previous, InclusiveRange16 next, ref InclusiveRange16 result)
    {
        if (next._start == short.MinValue || next._start - 1 <= previous._end)
        {
            result = new InclusiveRange16(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<InclusiveRange16> enumerator, out InclusiveRange16 result)
    {
        InclusiveRange16 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Object Method Implementations

    /// <summary>
    /// Determines if this range is equal to the specified range. Empty ranges are only considered equal if their start and end values match.
    /// </summary>
    /// <remarks>
    ///
    /// </remarks>
    public bool Equals(InclusiveRange16 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the given object.
    /// </summary>
    public override bool Equals(object? obj) => obj is InclusiveRange16 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region IEnumerable

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<short> IEnumerable<short>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<short>
    {
        private readonly short _end;
        private short _current;
        private short _next;

        internal Enumerator(short start, short end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next <= _end && _current != short.MaxValue)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public short Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="int"/> values with an inclusive start and end.
/// </summary>
[DebuggerDisplay("[{Start}..{End}], Count: {Count}")]
public readonly struct InclusiveRange32 : IInclusiveRange<int>, IEquatable<InclusiveRange32>, IAnyRange
{
    private static EmptyRangeEqualityComparer<InclusiveRange32>? _emptyEqualityComparer;

    private readonly int _start;
    private readonly int _end;

    /// <summary>
    /// Creates a new instance of the InclusiveRange32 structure with the specified start and inclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then an empty range is created.
    /// </remarks>
    public InclusiveRange32(int start, int end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the InclusiveRange32 structure with a single value in the range.
    /// </summary>
    public static InclusiveRange32 SingleValue(int value)
    {
        return new InclusiveRange32(value, value);
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator ==(InclusiveRange32 x, InclusiveRange32 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator !=(InclusiveRange32 x, InclusiveRange32 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <see cref="int.MaxValue"/> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static InclusiveRange32 Empty => new InclusiveRange32(int.MaxValue, 0);

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<InclusiveRange32> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the start of the range.
    /// </summary>
    public int Start => _start;

    /// <summary>
    /// Gets the end of the range.
    /// </summary>
    public int End => _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public long Count => IsEmpty ? 0 : (long)_end - (long)_start + 1;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start > _end;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range.
    /// </summary>
    public InclusiveRange32 StartAt(int start) => new(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value.
    /// </summary>
    public InclusiveRange32 EndAt(int end) => new(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public InclusiveRange32 ExpandToInclude(int value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value > _end)
            return EndAt(value);

        if (value < _start)
            return StartAt(value);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range and returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public InclusiveRange32 IntersectWith(InclusiveRange32 range) => new InclusiveRange32(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. Throws
    /// <see cref="ArgumentException"/> if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public InclusiveRange32 UnionWith(InclusiveRange32 range)
    {
        InclusiveRange32 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. Returns false if there
    /// is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(InclusiveRange32 range, out InclusiveRange32 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<InclusiveRange32> Coalesce(IEnumerable<InclusiveRange32> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<InclusiveRange32> CoalesceOrdered(IEnumerable<InclusiveRange32> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        InclusiveRange32 previous;
        InclusiveRange32 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(InclusiveRange32 previous, InclusiveRange32 next, ref InclusiveRange32 result)
    {
        if (next._start == int.MinValue || next._start - 1 <= previous._end)
        {
            result = new InclusiveRange32(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<InclusiveRange32> enumerator, out InclusiveRange32 result)
    {
        InclusiveRange32 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Object Method Implementations

    /// <summary>
    /// Determines if this range is equal to the specified range. Empty ranges are only considered equal if their start and end values match.
    /// </summary>
    /// <remarks>
    ///
    /// </remarks>
    public bool Equals(InclusiveRange32 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the given object.
    /// </summary>
    public override bool Equals(object? obj) => obj is InclusiveRange32 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region IEnumerable

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<int> IEnumerable<int>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<int>
    {
        private readonly int _end;
        private int _current;
        private int _next;

        internal Enumerator(int start, int end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next <= _end && _current != int.MaxValue)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public int Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="sbyte"/> values with an inclusive start and end.
/// </summary>
[DebuggerDisplay("[{Start}..{End}], Count: {Count}")]
public readonly struct InclusiveSRange8 : IInclusiveRange<sbyte>, IEquatable<InclusiveSRange8>, IAnyRange
{
    private static EmptyRangeEqualityComparer<InclusiveSRange8>? _emptyEqualityComparer;

    private readonly sbyte _start;
    private readonly sbyte _end;

    /// <summary>
    /// Creates a new instance of the InclusiveSRange8 structure with the specified start and inclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then an empty range is created.
    /// </remarks>
    public InclusiveSRange8(sbyte start, sbyte end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the InclusiveSRange8 structure with a single value in the range.
    /// </summary>
    public static InclusiveSRange8 SingleValue(sbyte value)
    {
        return new InclusiveSRange8(value, value);
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator ==(InclusiveSRange8 x, InclusiveSRange8 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator !=(InclusiveSRange8 x, InclusiveSRange8 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <see cref="sbyte.MaxValue"/> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static InclusiveSRange8 Empty => new InclusiveSRange8(sbyte.MaxValue, 0);

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<InclusiveSRange8> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the start of the range.
    /// </summary>
    public sbyte Start => _start;

    /// <summary>
    /// Gets the end of the range.
    /// </summary>
    public sbyte End => _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public int Count => IsEmpty ? 0 : (int)_end - (int)_start + 1;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start > _end;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range.
    /// </summary>
    public InclusiveSRange8 StartAt(sbyte start) => new(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value.
    /// </summary>
    public InclusiveSRange8 EndAt(sbyte end) => new(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public InclusiveSRange8 ExpandToInclude(sbyte value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value > _end)
            return EndAt(value);

        if (value < _start)
            return StartAt(value);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range and returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public InclusiveSRange8 IntersectWith(InclusiveSRange8 range) => new InclusiveSRange8(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. Throws
    /// <see cref="ArgumentException"/> if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public InclusiveSRange8 UnionWith(InclusiveSRange8 range)
    {
        InclusiveSRange8 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. Returns false if there
    /// is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(InclusiveSRange8 range, out InclusiveSRange8 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<InclusiveSRange8> Coalesce(IEnumerable<InclusiveSRange8> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<InclusiveSRange8> CoalesceOrdered(IEnumerable<InclusiveSRange8> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        InclusiveSRange8 previous;
        InclusiveSRange8 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(InclusiveSRange8 previous, InclusiveSRange8 next, ref InclusiveSRange8 result)
    {
        if (next._start == sbyte.MinValue || next._start - 1 <= previous._end)
        {
            result = new InclusiveSRange8(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<InclusiveSRange8> enumerator, out InclusiveSRange8 result)
    {
        InclusiveSRange8 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Object Method Implementations

    /// <summary>
    /// Determines if this range is equal to the specified range. Empty ranges are only considered equal if their start and end values match.
    /// </summary>
    /// <remarks>
    ///
    /// </remarks>
    public bool Equals(InclusiveSRange8 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the given object.
    /// </summary>
    public override bool Equals(object? obj) => obj is InclusiveSRange8 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region IEnumerable

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<sbyte> IEnumerable<sbyte>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<sbyte>
    {
        private readonly sbyte _end;
        private sbyte _current;
        private sbyte _next;

        internal Enumerator(sbyte start, sbyte end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next <= _end && _current != sbyte.MaxValue)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public sbyte Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="ushort"/> values with an inclusive start and end.
/// </summary>
[DebuggerDisplay("[{Start}..{End}], Count: {Count}")]
public readonly struct InclusiveURange16 : IInclusiveRange<ushort>, IEquatable<InclusiveURange16>, IAnyRange
{
    private static EmptyRangeEqualityComparer<InclusiveURange16>? _emptyEqualityComparer;

    private readonly ushort _start;
    private readonly ushort _end;

    /// <summary>
    /// Creates a new instance of the InclusiveURange16 structure with the specified start and inclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then an empty range is created.
    /// </remarks>
    public InclusiveURange16(ushort start, ushort end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the InclusiveURange16 structure with a single value in the range.
    /// </summary>
    public static InclusiveURange16 SingleValue(ushort value)
    {
        return new InclusiveURange16(value, value);
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator ==(InclusiveURange16 x, InclusiveURange16 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator !=(InclusiveURange16 x, InclusiveURange16 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <see cref="ushort.MaxValue"/> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static InclusiveURange16 Empty => new InclusiveURange16(ushort.MaxValue, 0);

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<InclusiveURange16> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the start of the range.
    /// </summary>
    public ushort Start => _start;

    /// <summary>
    /// Gets the end of the range.
    /// </summary>
    public ushort End => _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public int Count => IsEmpty ? 0 : (int)_end - (int)_start + 1;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start > _end;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range.
    /// </summary>
    public InclusiveURange16 StartAt(ushort start) => new(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value.
    /// </summary>
    public InclusiveURange16 EndAt(ushort end) => new(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public InclusiveURange16 ExpandToInclude(ushort value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value > _end)
            return EndAt(value);

        if (value < _start)
            return StartAt(value);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range and returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public InclusiveURange16 IntersectWith(InclusiveURange16 range) => new InclusiveURange16(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. Throws
    /// <see cref="ArgumentException"/> if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public InclusiveURange16 UnionWith(InclusiveURange16 range)
    {
        InclusiveURange16 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. Returns false if there
    /// is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(InclusiveURange16 range, out InclusiveURange16 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<InclusiveURange16> Coalesce(IEnumerable<InclusiveURange16> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<InclusiveURange16> CoalesceOrdered(IEnumerable<InclusiveURange16> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        InclusiveURange16 previous;
        InclusiveURange16 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(InclusiveURange16 previous, InclusiveURange16 next, ref InclusiveURange16 result)
    {
        if (next._start == ushort.MinValue || next._start - 1 <= previous._end)
        {
            result = new InclusiveURange16(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<InclusiveURange16> enumerator, out InclusiveURange16 result)
    {
        InclusiveURange16 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Object Method Implementations

    /// <summary>
    /// Determines if this range is equal to the specified range. Empty ranges are only considered equal if their start and end values match.
    /// </summary>
    /// <remarks>
    ///
    /// </remarks>
    public bool Equals(InclusiveURange16 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the given object.
    /// </summary>
    public override bool Equals(object? obj) => obj is InclusiveURange16 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region IEnumerable

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<ushort> IEnumerable<ushort>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<ushort>
    {
        private readonly ushort _end;
        private ushort _current;
        private ushort _next;

        internal Enumerator(ushort start, ushort end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next <= _end && _current != ushort.MaxValue)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public ushort Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="uint"/> values with an inclusive start and end.
/// </summary>
[DebuggerDisplay("[{Start}..{End}], Count: {Count}")]
public readonly struct InclusiveURange32 : IInclusiveRange<uint>, IEquatable<InclusiveURange32>, IAnyRange
{
    private static EmptyRangeEqualityComparer<InclusiveURange32>? _emptyEqualityComparer;

    private readonly uint _start;
    private readonly uint _end;

    /// <summary>
    /// Creates a new instance of the InclusiveURange32 structure with the specified start and inclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then an empty range is created.
    /// </remarks>
    public InclusiveURange32(uint start, uint end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the InclusiveURange32 structure with a single value in the range.
    /// </summary>
    public static InclusiveURange32 SingleValue(uint value)
    {
        return new InclusiveURange32(value, value);
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator ==(InclusiveURange32 x, InclusiveURange32 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges are considered equal to each other, even if they have different start/end values.
    /// </summary>
    public static bool operator !=(InclusiveURange32 x, InclusiveURange32 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <see cref="uint.MaxValue"/> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static InclusiveURange32 Empty => new InclusiveURange32(uint.MaxValue, 0);

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<InclusiveURange32> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the start of the range.
    /// </summary>
    public uint Start => _start;

    /// <summary>
    /// Gets the end of the range.
    /// </summary>
    public uint End => _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public long Count => IsEmpty ? 0 : (long)_end - (long)_start + 1;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start > _end;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range.
    /// </summary>
    public InclusiveURange32 StartAt(uint start) => new(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value.
    /// </summary>
    public InclusiveURange32 EndAt(uint end) => new(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public InclusiveURange32 ExpandToInclude(uint value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value > _end)
            return EndAt(value);

        if (value < _start)
            return StartAt(value);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range and returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public InclusiveURange32 IntersectWith(InclusiveURange32 range) => new InclusiveURange32(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. Throws
    /// <see cref="ArgumentException"/> if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public InclusiveURange32 UnionWith(InclusiveURange32 range)
    {
        InclusiveURange32 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. Returns false if there
    /// is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(InclusiveURange32 range, out InclusiveURange32 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<InclusiveURange32> Coalesce(IEnumerable<InclusiveURange32> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<InclusiveURange32> CoalesceOrdered(IEnumerable<InclusiveURange32> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        InclusiveURange32 previous;
        InclusiveURange32 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(InclusiveURange32 previous, InclusiveURange32 next, ref InclusiveURange32 result)
    {
        if (next._start == uint.MinValue || next._start - 1 <= previous._end)
        {
            result = new InclusiveURange32(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<InclusiveURange32> enumerator, out InclusiveURange32 result)
    {
        InclusiveURange32 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Object Method Implementations

    /// <summary>
    /// Determines if this range is equal to the specified range. Empty ranges are only considered equal if their start and end values match.
    /// </summary>
    /// <remarks>
    ///
    /// </remarks>
    public bool Equals(InclusiveURange32 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the given object.
    /// </summary>
    public override bool Equals(object? obj) => obj is InclusiveURange32 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region IEnumerable

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<uint> IEnumerable<uint>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<uint>
    {
        private readonly uint _end;
        private uint _current;
        private uint _next;

        internal Enumerator(uint start, uint end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next <= _end && _current != uint.MaxValue)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public uint Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

