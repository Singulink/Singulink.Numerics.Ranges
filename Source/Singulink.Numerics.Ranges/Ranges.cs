// <auto-generated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

#nullable enable

namespace Singulink.Numerics;

/// <summary>
/// Represents a range of <see cref="byte"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct Range8 : IRange<byte>, IEquatable<Range8>, IAnyRange
{
    private static EmptyRangeEqualityComparer<Range8>? _emptyEqualityComparer;

    private readonly byte _start;
    private readonly byte _end;

    /// <summary>
    /// Creates a new instance of the Range8 structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public Range8(byte start, byte end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the Range8 structure with a single value in the range. The value must be less than <see cref="byte.MaxValue"/>.
    /// </summary>
    public static Range8 SingleValue(byte value)
    {
        if (value == byte.MaxValue)
            Throw.Value_OutOfRange();

        return new Range8(value, (byte)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the Range8 structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="byte.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static Range8 Inclusive(byte start, byte end)
    {
        if (end == byte.MaxValue)
            Throw.End_OutOfRange();

        return new Range8(start, (byte)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(Range8 x, Range8 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(Range8 x, Range8 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static Range8 Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<Range8> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public byte Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public byte End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public int Count => IsEmpty ? 0 : (int)_end - (int)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public Range8 StartAt(byte start) => new Range8(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public Range8 EndAt(byte end) => new Range8(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="byte.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public Range8 EndAtInclusive(byte end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public Range8 ExpandToInclude(byte value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new Range8(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public Range8 IntersectWith(Range8 range) => new Range8(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public Range8 UnionWith(Range8 range)
    {
        Range8 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(Range8 range, out Range8 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<Range8> Coalesce(IEnumerable<Range8> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<Range8> CoalesceOrdered(IEnumerable<Range8> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        Range8 previous;
        Range8 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(Range8 previous, Range8 next, ref Range8 result)
    {
        if (next._start <= previous._end)
        {
            result = new Range8(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<Range8> enumerator, out Range8 result)
    {
        Range8 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(Range8 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is Range8 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<byte> IEnumerable<byte>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<byte>
    {
        private readonly byte _end;
        private byte _current;
        private byte _next;

        internal Enumerator(byte start, byte end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public byte Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="short"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct Range16 : IRange<short>, IEquatable<Range16>, IAnyRange
{
    private static EmptyRangeEqualityComparer<Range16>? _emptyEqualityComparer;

    private readonly short _start;
    private readonly short _end;

    /// <summary>
    /// Creates a new instance of the Range16 structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public Range16(short start, short end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the Range16 structure with a single value in the range. The value must be less than <see cref="short.MaxValue"/>.
    /// </summary>
    public static Range16 SingleValue(short value)
    {
        if (value == short.MaxValue)
            Throw.Value_OutOfRange();

        return new Range16(value, (short)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the Range16 structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="short.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static Range16 Inclusive(short start, short end)
    {
        if (end == short.MaxValue)
            Throw.End_OutOfRange();

        return new Range16(start, (short)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(Range16 x, Range16 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(Range16 x, Range16 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static Range16 Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<Range16> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public short Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public short End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public int Count => IsEmpty ? 0 : (int)_end - (int)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public Range16 StartAt(short start) => new Range16(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public Range16 EndAt(short end) => new Range16(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="short.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public Range16 EndAtInclusive(short end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public Range16 ExpandToInclude(short value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new Range16(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public Range16 IntersectWith(Range16 range) => new Range16(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public Range16 UnionWith(Range16 range)
    {
        Range16 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(Range16 range, out Range16 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<Range16> Coalesce(IEnumerable<Range16> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<Range16> CoalesceOrdered(IEnumerable<Range16> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        Range16 previous;
        Range16 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(Range16 previous, Range16 next, ref Range16 result)
    {
        if (next._start <= previous._end)
        {
            result = new Range16(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<Range16> enumerator, out Range16 result)
    {
        Range16 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(Range16 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is Range16 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<short> IEnumerable<short>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<short>
    {
        private readonly short _end;
        private short _current;
        private short _next;

        internal Enumerator(short start, short end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public short Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="int"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct Range32 : IRange<int>, IEquatable<Range32>, IAnyRange
{
    private static EmptyRangeEqualityComparer<Range32>? _emptyEqualityComparer;

    private readonly int _start;
    private readonly int _end;

    /// <summary>
    /// Creates a new instance of the Range32 structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public Range32(int start, int end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the Range32 structure with a single value in the range. The value must be less than <see cref="int.MaxValue"/>.
    /// </summary>
    public static Range32 SingleValue(int value)
    {
        if (value == int.MaxValue)
            Throw.Value_OutOfRange();

        return new Range32(value, (int)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the Range32 structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="int.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static Range32 Inclusive(int start, int end)
    {
        if (end == int.MaxValue)
            Throw.End_OutOfRange();

        return new Range32(start, (int)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(Range32 x, Range32 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(Range32 x, Range32 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static Range32 Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<Range32> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public int Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public int End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public long Count => IsEmpty ? 0 : (long)_end - (long)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public Range32 StartAt(int start) => new Range32(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public Range32 EndAt(int end) => new Range32(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="int.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public Range32 EndAtInclusive(int end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public Range32 ExpandToInclude(int value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new Range32(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public Range32 IntersectWith(Range32 range) => new Range32(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public Range32 UnionWith(Range32 range)
    {
        Range32 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(Range32 range, out Range32 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<Range32> Coalesce(IEnumerable<Range32> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<Range32> CoalesceOrdered(IEnumerable<Range32> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        Range32 previous;
        Range32 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(Range32 previous, Range32 next, ref Range32 result)
    {
        if (next._start <= previous._end)
        {
            result = new Range32(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<Range32> enumerator, out Range32 result)
    {
        Range32 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(Range32 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is Range32 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<int> IEnumerable<int>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<int>
    {
        private readonly int _end;
        private int _current;
        private int _next;

        internal Enumerator(int start, int end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public int Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="long"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct Range64 : IRange<long>, IEquatable<Range64>, IAnyRange
{
    private static EmptyRangeEqualityComparer<Range64>? _emptyEqualityComparer;

    private readonly long _start;
    private readonly long _end;

    /// <summary>
    /// Creates a new instance of the Range64 structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public Range64(long start, long end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the Range64 structure with a single value in the range. The value must be less than <see cref="long.MaxValue"/>.
    /// </summary>
    public static Range64 SingleValue(long value)
    {
        if (value == long.MaxValue)
            Throw.Value_OutOfRange();

        return new Range64(value, (long)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the Range64 structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="long.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static Range64 Inclusive(long start, long end)
    {
        if (end == long.MaxValue)
            Throw.End_OutOfRange();

        return new Range64(start, (long)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(Range64 x, Range64 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(Range64 x, Range64 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static Range64 Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<Range64> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public long Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public long End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public ulong Count => IsEmpty ? 0 : (ulong)_end - (ulong)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public Range64 StartAt(long start) => new Range64(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public Range64 EndAt(long end) => new Range64(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="long.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public Range64 EndAtInclusive(long end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public Range64 ExpandToInclude(long value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new Range64(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public Range64 IntersectWith(Range64 range) => new Range64(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public Range64 UnionWith(Range64 range)
    {
        Range64 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(Range64 range, out Range64 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<Range64> Coalesce(IEnumerable<Range64> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<Range64> CoalesceOrdered(IEnumerable<Range64> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        Range64 previous;
        Range64 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(Range64 previous, Range64 next, ref Range64 result)
    {
        if (next._start <= previous._end)
        {
            result = new Range64(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<Range64> enumerator, out Range64 result)
    {
        Range64 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(Range64 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is Range64 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<long> IEnumerable<long>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<long>
    {
        private readonly long _end;
        private long _current;
        private long _next;

        internal Enumerator(long start, long end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public long Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="sbyte"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct SRange8 : IRange<sbyte>, IEquatable<SRange8>, IAnyRange
{
    private static EmptyRangeEqualityComparer<SRange8>? _emptyEqualityComparer;

    private readonly sbyte _start;
    private readonly sbyte _end;

    /// <summary>
    /// Creates a new instance of the SRange8 structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public SRange8(sbyte start, sbyte end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the SRange8 structure with a single value in the range. The value must be less than <see cref="sbyte.MaxValue"/>.
    /// </summary>
    public static SRange8 SingleValue(sbyte value)
    {
        if (value == sbyte.MaxValue)
            Throw.Value_OutOfRange();

        return new SRange8(value, (sbyte)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the SRange8 structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="sbyte.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static SRange8 Inclusive(sbyte start, sbyte end)
    {
        if (end == sbyte.MaxValue)
            Throw.End_OutOfRange();

        return new SRange8(start, (sbyte)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(SRange8 x, SRange8 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(SRange8 x, SRange8 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static SRange8 Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<SRange8> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public sbyte Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public sbyte End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public int Count => IsEmpty ? 0 : (int)_end - (int)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public SRange8 StartAt(sbyte start) => new SRange8(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public SRange8 EndAt(sbyte end) => new SRange8(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="sbyte.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public SRange8 EndAtInclusive(sbyte end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public SRange8 ExpandToInclude(sbyte value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new SRange8(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public SRange8 IntersectWith(SRange8 range) => new SRange8(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public SRange8 UnionWith(SRange8 range)
    {
        SRange8 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(SRange8 range, out SRange8 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<SRange8> Coalesce(IEnumerable<SRange8> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<SRange8> CoalesceOrdered(IEnumerable<SRange8> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        SRange8 previous;
        SRange8 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(SRange8 previous, SRange8 next, ref SRange8 result)
    {
        if (next._start <= previous._end)
        {
            result = new SRange8(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<SRange8> enumerator, out SRange8 result)
    {
        SRange8 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(SRange8 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is SRange8 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<sbyte> IEnumerable<sbyte>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<sbyte>
    {
        private readonly sbyte _end;
        private sbyte _current;
        private sbyte _next;

        internal Enumerator(sbyte start, sbyte end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public sbyte Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="ushort"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct URange16 : IRange<ushort>, IEquatable<URange16>, IAnyRange
{
    private static EmptyRangeEqualityComparer<URange16>? _emptyEqualityComparer;

    private readonly ushort _start;
    private readonly ushort _end;

    /// <summary>
    /// Creates a new instance of the URange16 structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public URange16(ushort start, ushort end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the URange16 structure with a single value in the range. The value must be less than <see cref="ushort.MaxValue"/>.
    /// </summary>
    public static URange16 SingleValue(ushort value)
    {
        if (value == ushort.MaxValue)
            Throw.Value_OutOfRange();

        return new URange16(value, (ushort)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the URange16 structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="ushort.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static URange16 Inclusive(ushort start, ushort end)
    {
        if (end == ushort.MaxValue)
            Throw.End_OutOfRange();

        return new URange16(start, (ushort)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(URange16 x, URange16 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(URange16 x, URange16 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static URange16 Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<URange16> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public ushort Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public ushort End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public int Count => IsEmpty ? 0 : (int)_end - (int)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public URange16 StartAt(ushort start) => new URange16(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public URange16 EndAt(ushort end) => new URange16(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="ushort.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public URange16 EndAtInclusive(ushort end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public URange16 ExpandToInclude(ushort value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new URange16(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public URange16 IntersectWith(URange16 range) => new URange16(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public URange16 UnionWith(URange16 range)
    {
        URange16 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(URange16 range, out URange16 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<URange16> Coalesce(IEnumerable<URange16> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<URange16> CoalesceOrdered(IEnumerable<URange16> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        URange16 previous;
        URange16 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(URange16 previous, URange16 next, ref URange16 result)
    {
        if (next._start <= previous._end)
        {
            result = new URange16(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<URange16> enumerator, out URange16 result)
    {
        URange16 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(URange16 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is URange16 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<ushort> IEnumerable<ushort>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<ushort>
    {
        private readonly ushort _end;
        private ushort _current;
        private ushort _next;

        internal Enumerator(ushort start, ushort end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public ushort Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="uint"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct URange32 : IRange<uint>, IEquatable<URange32>, IAnyRange
{
    private static EmptyRangeEqualityComparer<URange32>? _emptyEqualityComparer;

    private readonly uint _start;
    private readonly uint _end;

    /// <summary>
    /// Creates a new instance of the URange32 structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public URange32(uint start, uint end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the URange32 structure with a single value in the range. The value must be less than <see cref="uint.MaxValue"/>.
    /// </summary>
    public static URange32 SingleValue(uint value)
    {
        if (value == uint.MaxValue)
            Throw.Value_OutOfRange();

        return new URange32(value, (uint)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the URange32 structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="uint.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static URange32 Inclusive(uint start, uint end)
    {
        if (end == uint.MaxValue)
            Throw.End_OutOfRange();

        return new URange32(start, (uint)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(URange32 x, URange32 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(URange32 x, URange32 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static URange32 Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<URange32> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public uint Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public uint End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public long Count => IsEmpty ? 0 : (long)_end - (long)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public URange32 StartAt(uint start) => new URange32(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public URange32 EndAt(uint end) => new URange32(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="uint.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public URange32 EndAtInclusive(uint end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public URange32 ExpandToInclude(uint value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new URange32(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public URange32 IntersectWith(URange32 range) => new URange32(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public URange32 UnionWith(URange32 range)
    {
        URange32 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(URange32 range, out URange32 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<URange32> Coalesce(IEnumerable<URange32> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<URange32> CoalesceOrdered(IEnumerable<URange32> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        URange32 previous;
        URange32 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(URange32 previous, URange32 next, ref URange32 result)
    {
        if (next._start <= previous._end)
        {
            result = new URange32(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<URange32> enumerator, out URange32 result)
    {
        URange32 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(URange32 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is URange32 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<uint> IEnumerable<uint>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<uint>
    {
        private readonly uint _end;
        private uint _current;
        private uint _next;

        internal Enumerator(uint start, uint end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public uint Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

/// <summary>
/// Represents a range of <see cref="ulong"/> values.
/// </summary>
[DebuggerDisplay("[{Start}..{End}), Count: {Count}")]
public readonly struct URange64 : IRange<ulong>, IEquatable<URange64>, IAnyRange
{
    private static EmptyRangeEqualityComparer<URange64>? _emptyEqualityComparer;

    private readonly ulong _start;
    private readonly ulong _end;

    /// <summary>
    /// Creates a new instance of the URange64 structure with the specified inclusive start and exclusive end value.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than or equal to the end value then the range is considered empty.
    /// </remarks>
    public URange64(ulong start, ulong end)
    {
        _start = start;
        _end = end;
    }

    /// <summary>
    /// Creates a new instance of the URange64 structure with a single value in the range. The value must be less than <see cref="ulong.MaxValue"/>.
    /// </summary>
    public static URange64 SingleValue(ulong value)
    {
        if (value == ulong.MaxValue)
            Throw.Value_OutOfRange();

        return new URange64(value, (ulong)(value + 1));
    }

    /// <summary>
    /// Creates a new instance of the URange64 structure with the specified inclusive start and end value. The end value must be less than
    /// <see cref="ulong.MaxValue"/>.
    /// </summary>
    /// <remarks>
    /// If the start value is greater than the end value then the range is considered empty.
    /// </remarks>
    public static URange64 Inclusive(ulong start, ulong end)
    {
        if (end == ulong.MaxValue)
            Throw.End_OutOfRange();

        return new URange64(start, (ulong)(end + 1));
    }

    /// <summary>
    /// Determines whether two ranges are equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator ==(URange64 x, URange64 y) => x.Equals(y);

    /// <summary>
    /// Determines whether two ranges are not equal. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public static bool operator !=(URange64 x, URange64 y) => !x.Equals(y);

    /// <summary>
    /// Gets an empty range with a <see cref="Start"/> value of <c>0</c> and an <see cref="End"/> value of <c>0</c>.
    /// </summary>
    public static URange64 Empty => default;

    /// <summary>
    /// Gets an equality comparer that treats empty ranges as equal, regardless of what their start and end values are.
    /// </summary>
    public static EqualityComparer<URange64> EmptyEqualityComparer => _emptyEqualityComparer ??= new();

    /// <summary>
    /// Gets the inclusive start value of the range.
    /// </summary>
    public ulong Start => _start;

    /// <summary>
    /// Gets the exclusive end value of the range.
    /// </summary>
    public ulong End => _end;

    /// <summary>
    /// Gets a value indicating whether the range is empty.
    /// </summary>
    public bool IsEmpty => _start >= _end;

    /// <summary>
    /// Gets the number of values in the range.
    /// </summary>
    public ulong Count => IsEmpty ? 0 : (ulong)_end - (ulong)_start;

    /// <summary>
    /// Gets a new range with the specified start value and the same end value as this range. Throws <see cref="InvalidOperationException"/> if this
    /// range is empty.
    /// </summary>
    public URange64 StartAt(ulong start) => new URange64(start, _end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified exclusive end value. Throws <see cref="InvalidOperationException"/> if
    /// this range is empty.
    /// </summary>
    public URange64 EndAt(ulong end) => new URange64(_start, end);

    /// <summary>
    /// Gets a new range with same start value as this range and the specified inclusive end value. The end value must be less than
    /// <see cref="ulong.MaxValue"/>. Throws <see cref="InvalidOperationException"/> if this range is empty.
    /// </summary>
    public URange64 EndAtInclusive(ulong end) => Inclusive(_start, end);

    /// <summary>
    /// Expands this range to include the given value. If this range is empty then a single value range containing the given value will be returned.
    /// </summary>
    public URange64 ExpandToInclude(ulong value)
    {
        if (IsEmpty)
            return SingleValue(value);

        if (value >= _end)
            return Inclusive(_start, value);

        if (value < _start)
            return new URange64(value, _end);

        return this;
    }

    /// <summary>
    /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
    /// </summary>
    /// <remarks>
    /// The resulting range will start at the greater <see cref="Start"/> value of ranges and end at the lesser <see cref="End"/> value of the ranges.
    /// </remarks>
    public URange64 IntersectWith(URange64 range) => new URange64(Math.Max(_start, range._start), Math.Min(_end, range._end));

    /// <summary>
    /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
    /// <see cref="ArgumentException"/> is thrown if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public URange64 UnionWith(URange64 range)
    {
        URange64 result;

        if (!TryUnionWith(range, out result))
            Throw.Range_UnionInvalid();

        return result;
    }

    /// <summary>
    /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
    /// and returns false if there is a gap between non-empty ranges. If both ranges are empty then the result is <see cref="Empty"/>.
    /// </summary>
    public bool TryUnionWith(URange64 range, out URange64 result)
    {
        if (IsEmpty)
        {
            result = range.IsEmpty ? Empty : range;
            return true;
        }

        if (range.IsEmpty)
        {
            result = this;
            return true;
        }

        result = default;

        if (_start <= range._start)
            return NonEmptyTryUnion(this, range, ref result);

        return NonEmptyTryUnion(range, this, ref result);
    }

    /// <summary>
    /// Coalesces a collection of ranges into a minimal set of combined ranges that contain all the values in the input ranges.
    /// </summary>
    /// <param name="ranges">The ranges to sort and attempt to combine.</param>
    /// <returns>The sorted list of combined ranges.</returns>
    /// <remarks>
    /// If the input ranges are known to be ordered by ascending <see cref="Start"/> order then consider using the <see cref="CoalesceOrdered" /> method for
    /// better performance.
    /// </remarks>
    public static IEnumerable<URange64> Coalesce(IEnumerable<URange64> ranges) => CoalesceOrdered(ranges.OrderBy(r => r.Start));

    /// <summary>
    /// Coalesces a collection ranges ordered by ascending <see cref="Start"/> order into a minimal set of combined ranges that contain all the values in
    /// the input ranges. The output will be incorrect if the ranges are not ordered.
    /// </summary>
    /// <param name="ranges">Ranges ordered by ascending <see cref="Start"/> order to attempt to combine.</param>
    /// <returns>The list of combined ranges.</returns>
    public static IEnumerable<URange64> CoalesceOrdered(IEnumerable<URange64> ranges)
    {
        var enumerator = ranges.GetEnumerator();

        URange64 previous;
        URange64 next;

        if (!TryGetNextNonEmpty(enumerator, out previous))
            yield break;

        while (TryGetNextNonEmpty(enumerator, out next))
        {
            if (!NonEmptyTryUnion(previous, next, ref previous))
            {
                yield return previous;
                previous = next;
            }
        }

        yield return previous;
    }

    private static bool NonEmptyTryUnion(URange64 previous, URange64 next, ref URange64 result)
    {
        if (next._start <= previous._end)
        {
            result = new URange64(previous._start, Math.Max(next._end, previous._end));
            return true;
        }

        return false;
    }

    private static bool TryGetNextNonEmpty(IEnumerator<URange64> enumerator, out URange64 result)
    {
        URange64 current;

        while (enumerator.MoveNext())
        {
            current = enumerator.Current;

            if (!current.IsEmpty)
            {
                result = current;
                return true;
            }
        }

        result = default;
        return false;
    }

    #region Base Method Overrides

    /// <summary>
    /// Determines whether this range is equal to the specified range. Empty ranges must have the same start and end values to be considered equal.
    /// </summary>
    /// <remarks>
    /// Use <see cref="EmptyEqualityComparer"/> for equality comparisons where empty ranges are considered equal regardless of their start and end values.
    /// </remarks>
    public bool Equals(URange64 other) => _start == other._start && _end == other._end;

    /// <summary>
    /// Determines if this range is equal to the specified object.
    /// </summary>
    public override bool Equals(object? obj) => obj is URange64 range && Equals(range);

    /// <summary>
    /// Gets the hash code for this range.
    /// </summary>
    public override int GetHashCode() => HashCode.Combine(_start, _end);

    /// <summary>
    /// Returns a string representation of the range.
    /// </summary>
    /// <returns></returns>
    public override string ToString() => $"{_start}..{_end}";

    #endregion

    #region Enumeration

    /// <summary>
    /// Gets an enumerator for this range.
    /// </summary>
    public Enumerator GetEnumerator() => new Enumerator(_start, _end);

    IEnumerator<ulong> IEnumerable<ulong>.GetEnumerator() => GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    /// <summary>
    /// Supports iteration over a range.
    /// </summary>
    public struct Enumerator : IEnumerator<ulong>
    {
        private readonly ulong _end;
        private ulong _current;
        private ulong _next;

        internal Enumerator(ulong start, ulong end)
        {
            _current = default;
            _next = start;
            _end = end;
        }

        /// <summary>
        /// Disposes the enumerator.
        /// </summary>
        public void Dispose() { }

        /// <summary>
        /// Advances the enumerator to the next value of the range.
        /// </summary>
        public bool MoveNext()
        {
            if (_next < _end)
            {
                _current = _next;
                _next++;
                return true;
            }

            return false;
        }

        /// <summary>
        /// Gets the value in the range at the current position of the enumerator.
        /// </summary>
        public ulong Current => _current;

        void IEnumerator.Reset() => throw new NotSupportedException();

        object IEnumerator.Current => _current;
    }

    #endregion
}

