// <auto-generated/>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

#nullable enable

namespace Singulink
{
    /// <summary>
    /// Represents a range of <see cref="byte"/> values.
    /// </summary>
    public readonly struct Range8 : IEquatable<Range8>, IEnumerable<byte>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static Range8 Empty => default;

        private readonly byte _start;
        private readonly byte _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the Range8 structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public Range8(byte start, byte end)
        {
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the byte structure with the specified start and end value.
        /// </summary>
        public Range8(byte startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(Range8 x, Range8 y) => x.Equals(y);

        public static bool operator !=(Range8 x, Range8 y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public byte Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public byte End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public int Count => _isNotEmpty ? (int)_end - (int)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public Range8 StartAt(byte start) => new Range8(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public Range8 EndAt(byte end) => new Range8(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public Range8 IntersectWith(Range8 range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new Range8(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public Range8 UnionWith(Range8 range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(Range8 range, out Range8 result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<Range8> Coalesce(IEnumerable<Range8> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref Range8 range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            Range8 first;
            Range8 second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new Range8(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(Range8 other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is Range8 range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<byte> IEnumerable<byte>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<byte>
        {
            private readonly byte _end;
            private byte _current;
            private byte _next;

            internal Enumerator(byte start, byte end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != byte.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public byte Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

    /// <summary>
    /// Represents a range of <see cref="short"/> values.
    /// </summary>
    public readonly struct Range16 : IEquatable<Range16>, IEnumerable<short>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static Range16 Empty => default;

        private readonly short _start;
        private readonly short _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the Range16 structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public Range16(short start, short end)
        {
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the short structure with the specified start and end value.
        /// </summary>
        public Range16(short startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(Range16 x, Range16 y) => x.Equals(y);

        public static bool operator !=(Range16 x, Range16 y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public short Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public short End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public int Count => _isNotEmpty ? (int)_end - (int)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public Range16 StartAt(short start) => new Range16(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public Range16 EndAt(short end) => new Range16(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public Range16 IntersectWith(Range16 range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new Range16(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public Range16 UnionWith(Range16 range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(Range16 range, out Range16 result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<Range16> Coalesce(IEnumerable<Range16> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref Range16 range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            Range16 first;
            Range16 second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new Range16(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(Range16 other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is Range16 range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<short> IEnumerable<short>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<short>
        {
            private readonly short _end;
            private short _current;
            private short _next;

            internal Enumerator(short start, short end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != short.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public short Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

    /// <summary>
    /// Represents a range of <see cref="int"/> values.
    /// </summary>
    public readonly struct Range32 : IEquatable<Range32>, IEnumerable<int>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static Range32 Empty => default;

        private readonly int _start;
        private readonly int _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the Range32 structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public Range32(int start, int end)
        {
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the int structure with the specified start and end value.
        /// </summary>
        public Range32(int startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(Range32 x, Range32 y) => x.Equals(y);

        public static bool operator !=(Range32 x, Range32 y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public int Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public int End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public long Count => _isNotEmpty ? (long)_end - (long)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public Range32 StartAt(int start) => new Range32(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public Range32 EndAt(int end) => new Range32(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public Range32 IntersectWith(Range32 range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new Range32(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public Range32 UnionWith(Range32 range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(Range32 range, out Range32 result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<Range32> Coalesce(IEnumerable<Range32> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref Range32 range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            Range32 first;
            Range32 second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new Range32(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(Range32 other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is Range32 range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<int> IEnumerable<int>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<int>
        {
            private readonly int _end;
            private int _current;
            private int _next;

            internal Enumerator(int start, int end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != int.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public int Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

    /// <summary>
    /// Represents a range of <see cref="long"/> values.
    /// </summary>
    public readonly struct Range64 : IEquatable<Range64>, IEnumerable<long>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static Range64 Empty => default;

        private readonly long _start;
        private readonly long _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the Range64 structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public Range64(long start, long end)
        {
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the long structure with the specified start and end value.
        /// </summary>
        public Range64(long startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(Range64 x, Range64 y) => x.Equals(y);

        public static bool operator !=(Range64 x, Range64 y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public long Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public long End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public ulong Count => _isNotEmpty ? (ulong)_end - (ulong)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public Range64 StartAt(long start) => new Range64(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public Range64 EndAt(long end) => new Range64(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public Range64 IntersectWith(Range64 range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new Range64(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public Range64 UnionWith(Range64 range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(Range64 range, out Range64 result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<Range64> Coalesce(IEnumerable<Range64> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref Range64 range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            Range64 first;
            Range64 second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new Range64(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(Range64 other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is Range64 range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<long> IEnumerable<long>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<long>
        {
            private readonly long _end;
            private long _current;
            private long _next;

            internal Enumerator(long start, long end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != long.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public long Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

    /// <summary>
    /// Represents a range of <see cref="sbyte"/> values.
    /// </summary>
    public readonly struct SRange8 : IEquatable<SRange8>, IEnumerable<sbyte>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static SRange8 Empty => default;

        private readonly sbyte _start;
        private readonly sbyte _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the SRange8 structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public SRange8(sbyte start, sbyte end)
        {
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the sbyte structure with the specified start and end value.
        /// </summary>
        public SRange8(sbyte startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(SRange8 x, SRange8 y) => x.Equals(y);

        public static bool operator !=(SRange8 x, SRange8 y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public sbyte Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public sbyte End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public int Count => _isNotEmpty ? (int)_end - (int)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public SRange8 StartAt(sbyte start) => new SRange8(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public SRange8 EndAt(sbyte end) => new SRange8(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public SRange8 IntersectWith(SRange8 range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new SRange8(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public SRange8 UnionWith(SRange8 range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(SRange8 range, out SRange8 result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<SRange8> Coalesce(IEnumerable<SRange8> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref SRange8 range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            SRange8 first;
            SRange8 second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new SRange8(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(SRange8 other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is SRange8 range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<sbyte> IEnumerable<sbyte>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<sbyte>
        {
            private readonly sbyte _end;
            private sbyte _current;
            private sbyte _next;

            internal Enumerator(sbyte start, sbyte end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != sbyte.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public sbyte Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

    /// <summary>
    /// Represents a range of <see cref="ushort"/> values.
    /// </summary>
    public readonly struct URange16 : IEquatable<URange16>, IEnumerable<ushort>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static URange16 Empty => default;

        private readonly ushort _start;
        private readonly ushort _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the URange16 structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public URange16(ushort start, ushort end)
        {
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the ushort structure with the specified start and end value.
        /// </summary>
        public URange16(ushort startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(URange16 x, URange16 y) => x.Equals(y);

        public static bool operator !=(URange16 x, URange16 y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public ushort Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public ushort End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public int Count => _isNotEmpty ? (int)_end - (int)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public URange16 StartAt(ushort start) => new URange16(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public URange16 EndAt(ushort end) => new URange16(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public URange16 IntersectWith(URange16 range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new URange16(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public URange16 UnionWith(URange16 range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(URange16 range, out URange16 result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<URange16> Coalesce(IEnumerable<URange16> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref URange16 range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            URange16 first;
            URange16 second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new URange16(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(URange16 other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is URange16 range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<ushort> IEnumerable<ushort>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<ushort>
        {
            private readonly ushort _end;
            private ushort _current;
            private ushort _next;

            internal Enumerator(ushort start, ushort end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != ushort.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public ushort Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

    /// <summary>
    /// Represents a range of <see cref="uint"/> values.
    /// </summary>
    public readonly struct URange32 : IEquatable<URange32>, IEnumerable<uint>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static URange32 Empty => default;

        private readonly uint _start;
        private readonly uint _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the URange32 structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public URange32(uint start, uint end)
        {
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the uint structure with the specified start and end value.
        /// </summary>
        public URange32(uint startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(URange32 x, URange32 y) => x.Equals(y);

        public static bool operator !=(URange32 x, URange32 y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public uint Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public uint End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public long Count => _isNotEmpty ? (long)_end - (long)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public URange32 StartAt(uint start) => new URange32(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public URange32 EndAt(uint end) => new URange32(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public URange32 IntersectWith(URange32 range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new URange32(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public URange32 UnionWith(URange32 range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(URange32 range, out URange32 result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<URange32> Coalesce(IEnumerable<URange32> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref URange32 range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            URange32 first;
            URange32 second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new URange32(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(URange32 other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is URange32 range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<uint> IEnumerable<uint>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<uint>
        {
            private readonly uint _end;
            private uint _current;
            private uint _next;

            internal Enumerator(uint start, uint end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != uint.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public uint Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

    /// <summary>
    /// Represents a range of <see cref="ulong"/> values.
    /// </summary>
    public readonly struct URange64 : IEquatable<URange64>, IEnumerable<ulong>
    {
        /// <summary>
        /// Gets an empty range.
        /// </summary>
        public static URange64 Empty => default;

        private readonly ulong _start;
        private readonly ulong _end;
        private readonly bool _isNotEmpty;

        /// <summary>
        /// Initializes a new instance of the URange64 structure with the specified start and end value.
        /// </summary>
        /// <remarks>
        /// If the start value is larger than the end value than an empty range is created.
        /// </remarks>
        public URange64(ulong start, ulong end)
        {
            _start = start;
            _end = end;
            _isNotEmpty = start <= end;
        }

        /// <summary>
        /// Initializes a new instance of the ulong structure with the specified start and end value.
        /// </summary>
        public URange64(ulong startAndEnd)
        {
            _start = startAndEnd;
            _end = startAndEnd;
            _isNotEmpty = true;
        }

        #pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

        public static bool operator ==(URange64 x, URange64 y) => x.Equals(y);

        public static bool operator !=(URange64 x, URange64 y) => !x.Equals(y);

        #pragma warning restore CS1591 // Missing XML comment for publicly visible type or member

        /// <summary>
        /// Gets the start of the range.
        /// </summary>
        public ulong Start => _isNotEmpty ? _start : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the end of the range.
        /// </summary>
        public ulong End => _isNotEmpty ? _end : throw new InvalidOperationException("Empty ranges have no start or end.");

        /// <summary>
        /// Gets the number of values in the range.
        /// </summary>
        public ulong Count => _isNotEmpty ? (ulong)_end - (ulong)_start + 1 : 0;

        /// <summary>
        /// Gets a value indicating whether the range is empty.
        /// </summary>
        public bool IsEmpty => !_isNotEmpty;

        /// <summary>
        /// Gets a new range with the given start point and the same end point as this range.
        /// </summary>
        public URange64 StartAt(ulong start) => new URange64(start, End);

        /// <summary>
        /// Gets a new range with same start point as this range and the given end point.
        /// </summary>
        public URange64 EndAt(ulong end) => new URange64(Start, end);

        /// <summary>
        /// Intersects this range with the given range which returns a resulting range that contains only the values present in both ranges.
        /// </summary>
        public URange64 IntersectWith(URange64 range)
        {
            if (IsEmpty || range.IsEmpty || _start > range._end || range._start > _end)
                return Empty;

            return new URange64(Math.Max(_start, range._start), Math.Min(_end, range._end));
        }

        /// <summary>
        /// Combines this range with the given range to produce a resulting range that contains all the values from both ranges. An
        /// <see cref="ArgumentException"/> is thrown if there is a gap between the ranges.
        /// </summary>
        public URange64 UnionWith(URange64 range)
        {
            if (!TryUnionWith(ref range))
                throw new ArgumentException("Cannot form a union between this range and the range specified.", nameof(range));

            return range;
        }

        /// <summary>
        /// Tries to combine this range with the given range to produce a resulting range that contains all the values from both ranges. The operation fails
        /// and returns false if there is a gap between the ranges.
        /// </summary>
        public bool TryUnionWith(URange64 range, out URange64 result)
        {
            if (TryUnionWith(ref range)) {
                result = range;
                return true;
            }

            result = Empty;
            return false;
        }

        /// <summary>
        /// Coalesces a collection of ranges into a minimal set of combined ranges that contains all the values in the input ranges.
        /// </summary>
        /// <param name="inputRanges">The ranges to sort and attempt to combine.</param>
        /// <returns>The sorted list of combined ranges.</returns>
        public static IEnumerable<URange64> Coalesce(IEnumerable<URange64> inputRanges)
        {
            var enumerator = inputRanges.Where(r => !r.IsEmpty).OrderBy(r => r.Start).GetEnumerator();

            if (!enumerator.MoveNext())
                yield break;

            var range = enumerator.Current;

            while (enumerator.MoveNext()) {
                if (!enumerator.Current.TryUnionWith(ref range)) {
                    yield return range;
                    range = enumerator.Current;
                }
            }

            yield return range;
        }

        private bool TryUnionWith(ref URange64 range)
        {
            if (IsEmpty)
                return true;

            if (range.IsEmpty)
            {
                range = this;
                return true;
            }

            URange64 first;
            URange64 second;

            if (_start <= range._start) {
                first = this;
                second = range;
            }
            else {
                first = range;
                second = this;
            }

            if (first._start == second._start || second._start - 1 <= first.End) { // first test is necessary to ensure subtracting 1 does not overflow
                range = new URange64(first._start, Math.Max(End, range.End));
                return true;
            }

            return false;
        }

        #region Base Object Method Implementations

        /// <summary>
        /// Determines if this range is equal to the given range.
        /// </summary>
        public bool Equals(URange64 other)
        {
            if (IsEmpty)
                return other.IsEmpty;

            if (other.IsEmpty)
                return false;

            return _start == other._start && _end == other._end;
        }

        /// <summary>
        /// Determines if this range is equal to the given object.
        /// </summary>
        public override bool Equals(object? obj) => obj is URange64 range && Equals(range);

        /// <summary>
        /// Gets the hash code for this range.
        /// </summary>
        public override int GetHashCode() => IsEmpty ? 0 : HashCode.Combine(_start, _end);

        /// <summary>
        /// Returns a string representation of the range.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            if (IsEmpty)
                return string.Empty;

            return _start == _end ? _start.ToString() : $"{_start} to {_end}";
        }

        #endregion

        #region IEnumerable

        /// <summary>
        /// Gets an enumerator for this range.
        /// </summary>
        public Enumerator GetEnumerator() => new Enumerator(_start, _end);

        IEnumerator<ulong> IEnumerable<ulong>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        /// <summary>
        /// Supports iteration over a range.
        /// </summary>
        public struct Enumerator : IEnumerator<ulong>
        {
            private readonly ulong _end;
            private ulong _current;
            private ulong _next;

            internal Enumerator(ulong start, ulong end)
            {
                _current = default;
                _next = start;
                _end = end;
            }

            /// <summary>
            /// Disposes the enumerator.
            /// </summary>
            public void Dispose() { }

            /// <summary>
            /// Advances the enumerator to the next value of the range.
            /// </summary>
            public bool MoveNext()
            {
                if (_next <= _end && _current != ulong.MaxValue)
                {
                    _current = _next;
                    _next++;
                    return true;
                }

                return false;
            }

            /// <summary>
            /// Gets the value in the range at the current position of the enumerator.
            /// </summary>
            public ulong Current => _current;

            void IEnumerator.Reset() => throw new NotSupportedException();

            object IEnumerator.Current => _current;
        }

        #endregion
    }

}